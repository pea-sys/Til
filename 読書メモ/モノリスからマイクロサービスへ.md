## 必要十分なマイクロサービス

### マイクロサービス

- 独立デプロイ可能性：あるマイクロサービスに対する変更を、他のサービスに影響を与えることなく本番環境へデプロイできるという考え方。システムにおけるデプロイが実際にそのように管理されていることが重要。

* マイクロサービスにする場合、DB は分離すべき

* マイクロサービスはビジネス機能で分離
* UI も分離すべき
* マイクロサービスの利点は各サービス並行して独立した開発ができる。各サービスに適したアーキテクチャを組み合わせられる。柔軟性を与えてくれる。
* マイクロサービスはレイテンシーがモノリスより遥かに大きくなる欠点がある
* マイクロサービスはトランザクション処理を複雑にする欠点がある

### モノリス

- モノリスとは単一のプロセスとしてデプロイされているシステム
- モジュラーモノリスとは、単一のプロセスが別々のモジュールで校正され、それぞれ独立して作業できるものの、デプロイのために結合する必要があるシステム。  
  多くの企業にとってはモジュラーモノリスは優れた選択肢になる。
- モジュラーモノリスの課題は DB の分離がなされていないこと

- 分散モノリスとは、複数のサービスで構成されているものの、何らかの理由でシステム全体を一緒にデプロイされなければならなくなっているシステム

* モノリスの課題は結合の危険に対して脆弱
* モノリスの利点はシンプルなデプロイ方式。監視やトラブルシューティングなどの運用が簡単。コードの再利用が容易

### 結合と凝集

- 結合：あるものに対する変更がどれくらい別のものの変更を必要とするかを表す
- 凝集：関連するコードをどのようにグループ化するかを表す
- 構造は凝集度とが高く、結合度が低い場合に安定する

### 結合

- 実装結合：B の実装方法によって A が B に結合される結合。この場合、B を変更するときに A を変更する必要がある。

* 一時的結合：メッセージ送信とそのメッセージを処理する方法が時間的につながっている状態を一時的結合があると言う。分散環境での同期呼び出しによる連鎖通信が主な課題。

* デプロイ時結合：全てを一緒にデプロイする必要があるもの。
* ドメイン結合：複数の独立したサービスからなるシステムでは、参加サービス間に何らかの相互作用が存在する。マイクロサービスアーキテクチャでは、ドメイン結合と呼ぶ。

## 移行を計画する

### 3 つの重要な質問

マイクロサービスアーキテクチャ化を検討する際の質問

- 達成したことは何か？
- マイクロサービスの他に代替案はなかったか？
- どうすれば移行がうまくいってるか分かるだろうか？

### マイクロサービスを選択する理由

- チームの自律性を高める
- 市場投入までの時間を減らす
- 負荷への費用対効果が高いスケーリング
- 堅牢性を改善する
- 開発者の数を増やす
- 新しい技術を受け入れる

### マイクロサービスを選択しない理由

- 不明瞭なドメイン
- スタートアップ
- 顧客の環境にインストールして管理するソフトウェア
- もっともな理由を持たないとき

### チームを再編成する

- マイクロサービスへの移行を成功させるためにはアーキテクチャと組織の整合性を取ることが鍵になる

### どこから始めればいいか

- 小さい単位で少しずつマイクロサービスに移行する。段階的に対応することが重要。

### 移行パターン

抽象化によるブランチ手順(やっていることはストラングラーパターン)

- 1. 置き換える機能の抽象を作る
- 2. 作成した抽象を使用するように既存機能のクライアントを変更する
- 3. 機能を改良した抽象の実装を新たに作る。本書の文脈では、この新しい実装が新しいマイクロサービスを呼び出すことになる
- 4. 新しい実装を使用するように抽象を切り替える
- 5. 抽象を後始末し、古い実装を削除する(古い実装やフィーチャーフラグ等を消す。IF は残しておいても良い)

### モノリスを分離する

- 同時実行：新旧実装を本番環境にデプロイし、動作結果の突合を行い、差異がなくなったと確認できた時点で旧実装を捨てる。動作結果の突合には速度等の非機能要件を含めることを忘れないこと。
  同時実行の実装コストは大きいため、きわめてリスクが大きい変更にのみ適用する。

- デコレーティングコラボレーター：モノリス自体が変更出来ない場合に、デコレーターパターンで新しい機能を追加する。容易に実装できる場合のみ実用性がある。

* 変更データキャプチャ：データストアで行われた変更に反応するパターン。データを複製する必要がある場合に便利。
  - キャプチャ方法
    - データベーストリガー:使う場合は控えめに使うこと
    - トランザクションログの監視:メッセージブローカーのもので一般的な方法
    - バッチ差分コピー：定期的にデータベースをスキャンして変更を調べ、そのデータをコピーする。データベースの変更が前回からどれくらいあったか判別できる場合と出来ない場合がある

### データベースを分割する

- 共有データベース：マイクロサービスが独実に所有できるように分離するのが望ましい。難しければデータベースビューを用いる。読み取り専用の政敵参照データの場合は無理に分離する必要はない。
  また、複数のコンシューマがアクセスすることを前提にサービスがデータベースを公開している場合も分離の必要はない。
  - データベースビュー：データベースをリファクタリングして、コンシューマの参照処理に影響がないように修正前テーブルに合わせてビューを用意する。データベースの分離が現実的ではない場合に使用。

* データベースをラップ：複雑すぎるデータベースを薄いラッパーとして機能するサービスの後ろに隠す

* サービスのインターフェースとしてのデータベース：読み取り専用のデータベースを用意する。基礎となるデータベースが変更された際に読み取り専用のデータベースに反映する。反映には遅延が生じる。

### 所有権を移す

- 集約を公開するモノリス：あるサービスが必要とするデータを DB から取得するのではなく、集約サービスを作成し公開するように作り変えることでデータベースのデータ所有権を移す。

### データベースとコードのどちらを最初に分割するか

データベースを先に分解する

- パフォーマンスやデータの一貫性の問題を特に懸念している場合のみ、データベースを先に分解する

- 境界づけられたコンテキストごとのリポジトリパターン：モノリスを分割する方法を理解するためにモノリスと向き合いなおそうとしている場合に効果的なパターン

- 境界づけられたコンテキストごとのデータベースパターン：後々マイクロサービスに移行する際のリスクヘッジ。また、モノリスに多くの人が関わっている場合は有効。

コードを先に分解する

- データアクセス層としてのモノリス：モノリス自体を API のエンドポイントにして DB にアクセスするモデルへと移行する。新しいサービスを分離しやすくなる。データを管理するコードがモノリスに残っている場合に有効。

* 複数スキーマストレージ：新強いデータを保存する必要がある場合は新たにスキーマを追加する
* 専用の参照データスキーマ：参照用の専用スキーマに移す。データ重複を避けることが出来る。スキーマ変更により影響範囲が大きくなる可能性がある。

### トランザクション

- 2 フェーズコミット：リソースの長いロック時間を考慮すると非推奨の方法

* サーガ：関係するステップを独立して実行できる離散的な作業としてモデル化することで実現する。ロールバック処理・ロールフォワード処理は自前で実装する必要がある。
