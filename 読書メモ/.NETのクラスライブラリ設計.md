## 私的な感想

ここで書かれている内容はあくまでもフレームワークの開発チームの設計原則、コーディング標準です。  
必ずしも従う必要はありませんが、多くの内容は妥当だと思います。

## フレームワーク設計の基礎

- フレームワーク設計原則：フレームワークは使い方のシナリオのセットと、それらのシナリオを実装するコードサンプルの設計から始めなければならない  
  API 仕様には、その技術領域における上位 5~10 のシナリオを列挙するシナリオセクションを設け、さらにそれらのシナリオを実装するコードサンプルを示すべき  
  少なくとも 2 つ以上の言語で記述する。さまざまなコーディングスタイルを使用して、それらのシナリオを実装することが重要。

* API の例外は問題の修正に必要なことを説明する例外をスローすべき

* 上級者向けの API はサブ名前空間に配置すべき。例：System.Net は主要な API。System.Net.Sockets はそれよりも上級者向け。  
  逆もまた然り、Microsoft の開発者は StringBuilder を System 名前空間に入れるべきだったと悔やんでいる

* 単純なオーバーロードではパラメータの数を少なくし、プリミティブ型にすること

* 主流のシナリオ用の型に、上級者向けのシナリオ用のメンバーを持たせてはならない

* 単純でない初期化の実行をユーザーに一切要求してはならない

* 可能であれば、全てのプロパティとパラメータに対して、適切な規定値を提供する

* 単純なシナリオではフレームワークはドキュメントを必要とせずに使用可能でなければならない

* すべての APi に対して十分なドキュメントを用意する

* 識別子は冗長になっても自己説明的な名前にすること

* 主流のシナリオで使用される API では、抽象が多くなることを避ける

## 命名に関するガイドライン

- 名前空間、型、メンバー、及びジェネリック型パラメータの名前にパスカルケースを使用する

- パラメータの名前にキャメルケースを使用する

* キャメルケースである識別子の最初に単語を除き、２文字の頭字語の文字は両方とも大文字にする

* キャメルケースである識別子の最初の単語を除き、３文字以上の頭字語は最初の文字のみ大文字にする

* 誤った例：LogIn,MetaData,NameSpace,OK,PI,UserName,TimeStamp

* 全てのプログラミング言語が大文字と小文字を区別すると仮定してはならない

* 簡潔さより読み易さを優先する

* アンダースコアやハイフン、英数字以外の文字を仕様してはならない

* ハンガリアン記法を使用してはならない

* 広く使われているプログラミング言語のキーワードと衝突する識別子の使用を避ける

* 識別子の一部として、省略形や短縮形を使用してはならない

* 識別子に意味のある語がなく、かつパラメータの型が重要ではないというレアケースにおいては、value や item のような名前を使用する

* 既存の API の新しいバージョンを示すのに、サフィックスの追加を優先する(IntelliSense)

* Ex サフィックスは使用してはならない

* 次のパターンに従った DLL の命名を検討する

```
<会社>.<コンポーネント>.dll
```

- 次のパターンに従った名前空間の命名を検討する

```
<会社>.(<プロダクト>|<テクノロジ>)[.<機能>][.<サブ名前空間>]
```

- コアの名前空間同士で型が衝突するような名前を型につけてはならない(Stream や Log 等)

* クラスと構造体の名前は、名詞または名詞句でパスカルケースを使用する

* インターフェースの名前は形容詞、または場合によって名詞もしくは名詞句を使用する

* インターフェースは I をプレフィックスとして付ける

* インターフェースの標準実装は単純に接頭 I を除いたものにする

* 値としてビットフィールドを持つ列挙体は複数形の型名にする。ビットフィールドではない場合は単数形の型名にする。

* 列挙体の名前に Enum サフィックスを使用しない

* メソッド名には、動詞または動詞句を使用する

* プロパティ名には名詞、名詞句、形容詞、形容詞句を使用する

* コレクション型のプロパティは List や Collection のサフィックスをつけるのではなく複数形のフレーズを使用する

* ブール型のプロパティは肯定的なフレーズを使用する

* イベント名は動詞または動詞句を使用する

* 現在分詞と過去分詞を使用して、事前または字語の概念をイベント名に持たせる(例：Closing, Closed) Before や After は使用しない

* フィールド名にはパスカルケースを使用する

* フィールドの名前は名詞、名詞句、形容詞、形容詞句を使用する

* パラメータの名前にはキャメルケースを使用する

## 型の設計ガイドライン

- それぞれの型は関連するメンバーが適切に定義された集まりになるようにする

- 関連する機能の分野の階層構造に型を整理するために、名前空間を使用する

- 名前空間の階層が深くなりすぎないようにする

- 型のインスタンスのサイズが小さく、かつ寿命が短い場合、または別のオブジェクト、特に配列に含まれることが一般的な場合、クラスではなく構造体を定義することを検討する
  - プリミティブ型
  - インスタンスサイズが 24 バイト未満
  - 不変
  - ボックス化が頻繁ではない

* インターフェースよりもクラスとして定義する方を優先する

* 実装からコントラクトを分離するためには、インターフェースではなく抽象クラスを使用する

* 抽象クラスに public または protected internal なコンストラクターを定義してはならない
* 抽象クラスに protected または internal なコンストラクターを定義する

* 静的なクラスの使用を控えめにする
* 静的クラスを雑多な機能を放り込む場所としてはならない

* インターフェースを実装する型を少なくとも１つ提供する

* 以前にリリースしたインターフェースにメンバーを追加してはならない

* 構造体に既定のコンストラクターを提供してはならない

* 変更可能な値型を定義してはならない

* 変更可能な値型で変更を伴わないメソッドは readonly 修飾子をつけて宣言する

* すべてのインスタンスデータが 0,false,または null に設定されてる状態が正しい状態であるようにする

* 性能が非常に重要な低レベル処理用の特別な型以外では、ref struct 型を定義してはならない

* 値型に IEquatable<T>を実装する

* 静的メンバーとして定義された定数ではなく、列挙体を優先して使用する

* 列挙体に番兵値を定義してはならない

* 単純列挙体でゼロを表す値を提供する(None=0)

* 論理的にグループ化するための構造として public なネスト型を使用してはならない。グループ化には名前空間を使用する。

* ネスト型を public として公開することを避ける

* クライアントコードによってインスタンス化される必要があるものをネスト型にしてはならない

* public な型を含むアセンブリに CLSCompliant(True)属性を適用する

* public な型を含むアセンブリに AssemblyVersionAttribute を適用する

## メンバーの設計

- 最もパラメータ数の多いオーバーロードのみを virtual にする

* インターフェースのメソッドとクラスの仮想メソッドで、規定値付きパラメータを使用してはならない

* 理由がない限り、インターフェイスメンバーの明示的な実装を避ける

* プロパティ化メソッドの選択：パラメータの数が少ない場合はメソッド、多い場合はプロパティ

* その値がプロセス内のメモリに保存され、かつその値へのアクセスを提供するだけの場合には、メソッドではなくプロパティを使用する

* 処理が変換処理の場合はメソッドを使用する

* 処理がフィールドアクセスよりけた違いに遅い場合はメソッドを使用する

* 呼び出されるたびに異なる結果を返す場合はメソッドを使用する(DateTime.Now 等)

* 処理が配列を返す場合はメソッドを使用する(readonlyCollection のプロパティでもいい)

* ゲッターよりもアクセス許可の範囲が広いセッターを持つプロパティを提供してはならない

* プロパティのセッターが例外をスローする場合、プロパティの値は呼び出し前の値のままにする

* プロパティのゲッターは例外をスローしない

* 明らかに優れた名前の代替案がない限り、インデクサーの名前は Item とする

* セマンティクスが同等なインデクサーとメソッドの両方を提供してはならない

* 主要なプロパティの設定に対するショートカットとして、コンストラクターパラメーターを使用する

* コンストラクターパラメーターがプロパティの設定にのみ使用されるならば、コンストラクターパラメータとプロパティに同じ名前を使用する

* 適切な場合、インスタンスコンストラクターから例外をスローする

* クラスに public な既定のコンストラクターが必要ならば、明示的に宣言する

* 型コンストラクターを private にする

* 静的コンストラクターから例外を投げない

* イベントに対しては発火ではなく、発生という用語を使用する

* インスタンスイベントを発生させるとき、sender として null を渡してはならない
* 静的イベントを発生させるとき、sender として null を渡す

* public または protected なインスタンスフィールドを提供してはならない

* 絶対に変わることのない定数に対して、定数フィールドを使用する

* 拡張メソッドの this パラメータが null の時は、ArgumentNullWxception をスローする

* System.Object への拡張メソッドの定義を避ける。VB では呼び出せない。

* 拡張メソッドの意図が、インターフェイスへのメソッドの追加、ジェネリック型制約付きのメソッドの追加、または依存関係の管理である場合を除き、拡張メソッドを拡張対象の型と同じ名前空間に配置してはならない

* 異なる名前空間であったとしても、同一のシグネチャを持つ拡張メソッドを複数定義することを避ける。コンパイルエラーになる。

* 数値を表す構造体に対して、演算子のオーバーロードを定義する

* 対称性を持つように演算子のオーバーロードを定義する(例えば、==演算子をオーバーロードするなら!=演算子もオーバーロードする)

* ユーザーが明確に期待していない変換演算子を提供してはならない

* 情報の損失を伴う可能性のある暗黙的な変換演算子を提供してはならない

* キャスト演算子の結果が値の損失を伴う変換であり、かつその演算子のコントラクトが価の損失を許可しないならば、System.InvalidCastException をスローする

* 比較演算子を実装するのは IComparable<T>を実装する型でのみとする

* < 演算子と IEquatable<T>を実装する型では<=演算子を実装する

* ポインター、ポインターの配列、または多次元配列をパラメータとして受け取るメソッドを公開してはならない

* 仮想メンバーをオーバーライドするときや、インターフェイスメンバーを実装するときには、パラメータの名前に一貫性をもたせる

* 対象のメンバーのブール値パラメータが２つ以上になる場合は列挙体を使用する

* ３つ以上の値が必要になることは決してないという絶対的な確信がある場合を除き、ブール値のパラメータを使用してはならない

* public, protected,または明示的に実装されたメンバーに渡された引数に対してバリデーションを行う。バリデーションに失敗した場合には、System.ArgumentException またはその派生クラスのいずれかをスローする

* 引数に null が渡されかつ、そのメンバーが引数として null をサポートしていないならば、ArgumentNullException をスローする

* 列挙型のパラメータに対してバリデーションを行う。列挙体に変換できない場合は ArgumentOutOfRangeException をスローする。

* 列挙体の範囲チェックに Enum.IsDefined を使用してはならない。単純にリフレクションで遅い。また正数であることをチェックできない。

* 変更可能な型の引数は、バリデーション後に変更されている可能性を考慮する

* 参照渡し(ref または in)で参照型を渡してはならない

* 読み取り専用の参照渡し(in)で値型を渡してはならない

* params 配列引数に null が渡される可能性があることに注意する

* ポインターは CLS 準拠ではないので、ポインター引数を受け取る全てのメンバーに代替手段を提供する

* Tuple より自己記述的な型の使用を優先する

* 名前のないタプルより名前のあるタプルの使用を優先する

* 4 つ以上のフィールドを持つタプルを使用してはならない

* メソッドのパラメータとしてタプルを使用してはならない

* タプルに拡張メソッドを定義してはならない

* 性能が重要な PI でコールバックの使用は避ける

* コールバックを使用する API を定義するとき、カスタムデリゲートではなく、Func<...> Action<...>,Expression<...>の使用を優先する

* そうする十分な理由があり、かつ仮想メンバーの設計、テスト、保守に関するすべてのコストを認識していない限り、仮想メンバーを作成してはならない

* 仮想メンバーのアクセス修飾子は、public よりも protected の方も優先して使用する

* いくつかの具象実装と、その抽象を使用する API を開発することでテストされていない限り、抽象を提供してはならない

* 抽象を設計するとき、抽象クラスかインターフェイスかの選択は慎重に行う

* そうする十分な理由がない限り、クラスをシールしてはならない

* シールされた型に protected メンバーや仮想メンバーを宣言してはならない

* エラーコードは使用せず、例外を使用する

* 例外をスローすることで、実行の失敗を報告する

* 即座にプロセスを強制終了しなければならない状況にコードが陥ったならば、例外をスローするのではなく、System.Environment.FailFast を呼び出してプロセスを強制終了することを検討する

* 可能であれば、通常の制御フローのために例外を使用してはならない。一般的なケースにおいては、例外をスローするよりも Tester-Doer パターンや Try パターンの方が望ましい

* 例外フィルターブロックから例外をスローしてはならない

* finally ブロックから例外を明示的にスローすることを避ける

* 使用法えら０を伝えるために新しい例外型を作成してはならない。そうではなく基本クラスライブラリに存在する例外のいずれかをスローすること。

* 既存のフレームワーク例外を使用して伝えることができない、プログラムに固有のエラーを伝えるために新しい例外型を作成する

* 適切な例外型のうち、最も特定的な例外をスローする

* 例外をスローするときは、開発者を対象とした十分な分量で意味のあるメッセージを提供する

* 例外のメッセージでセキュリティ上問題となりえる情報を開示してはならない

* フレームワークのコードにおいて、System.Exception, System.SystemException などのような特定的ではない例外をキャッチしてエラーを握りつぶしてはならない

* アプリケーションのコードにおいて、System.Exception, System.SystemException などのような特定的ではない例外をキャッチしてエラーを握りつぶしてはならない

* キャッチしすぎてはならない。多くの場合、コールスタック上位への例外の伝搬が許可されるべきである。

* クリーンアップコードに try-finally を使用し、try-catch の使用は避ける。適切に記述された例外処理コードは、try-catch よりも try-finally の方が多く存在する。

* 例外をキャッチして再スローする場合、throw の後に何も指定しない方の書き方を使用する。ワトソンダンプの有効性を失わないようにする。

* 異なるコンテキストから例外を再スローする場合、ExceptionDispatchInfo を使用する

* 例外をラップするときには内部例外を指定する

* System.Exception または System.SystemException をスローしてはならない

* System.ApplicationException をスローまたは継承してはならない

* オブジェクトが不適切な状態にある場合、InvalidOperationException をスローする

* プロパティのセッターの暗黙的な value パラメータの名前として value を使用する

* 外部から呼び出し可能な API において、NullReferenceException,AccessViolationException または IndexOutOfRangeException の明示的または暗黙的なスローを認めてはならない

* StackOverflowException を明示的にスローしてはならない

* StackOverflowException をキャッチしてはならない

* OutOfMemoryException を明示的にスローしてはならない

* 明示的に ComException, SEHException、または ExecutionEngineException をスローしてはならない

* 呼び出し元が中止またはキャンセルを表すのに OperationCanceledException をスローする

* TaskCanceledExeption は OperationCanceledException としてキャッチするのが望ましい

* テキストを解析するメソッドに渡された入力文字列が書式の要件に準拠しないことを示すのに FormatException をスローする

* 現在の実行環境では処理を完了できないが、異なるランタイム、オペレーティングシステムでは完了できると思われることを示すのに PlatformNotSupportedException をスローする

* 例外のクラス名の末尾に Exception サフィックスを付ける

* 例外をランタイムシリアル化可能にする

* 例外が性能に悪影響を与えるかもしれないという懸念があることを理由にエラーコードを使用してはならない

* 一般的なシナリオで例外をスローするかもしれないメンバーについて、例外に関連する性能問題を避けるために、Tester-Doer パターンの使用を検討する

* 一般的なシナリオで例外をスローするかもしれないメンバーについて、例外に関連する性能問題を避けるために Try パターンの使用を検討する

* Try パターンを使用するメンバーのそれぞれについて、例外スロー版のメンバーを提供する

* Try メソッドが false を返す場合には、値を返す out パラメーターに default(T)を書き込む

## 使用法に関するガイドライン

- 公開 API では配列よりもコレクションの方を優先して使用する

- 不変型の配列であっても、配列そのものは変更可能であることを忘れない

- 配列型のプロパティを避ける

- カスタム属性クラスの名前に Attribute サフィックスを付ける

- カスタム属性に AttributeUsageAttribute 属性を適用する

- カスタム属性の省略可能引数に対して、設定可能なプロパティを提供する

- カスタム属性に対して、コンストラクタとプロパティセッターの両方から設定可能なプロパティを定義してはならない

- 可能であればカスタム属性をシールする。これによって属性の検索が高速になる。

- 公開 API で厳密に型指定されていないコレクションを使用してはならない

- 公開 API で ArrayList または List<T>を使用してはならない。Collection<T>,IEnumrable<T>,IList<T>,IReadOnlyList<T>等を使用すること

- 公開 API で Hashtable や Dictionary<TKey, TValue>を使用してはならない。IDictionary, IDictionary<TKey, Tvalue>などを使用すること

- 同じ型に IEnumerator<T>と IEnumerable<T>を実装してはならない

- パラメータの型として、できるだけ汎用的な型を使用する、パラメータとしてコレクションを受け取るメンバーのほとんどは IEnumrable<T>を使用する

- 設定可能でコレクション型のプロパティを提供してはならない

- 読み取り専用のコレクションを表すプロパティまたは戻り値には、ReadOnlyCollection<T>もしくは IEnumerable<T>を使用する

- コレクション型のプロパティやコレクション型を返すメソッドから、null を返してはならない。代わりに、空のコレクション、または空の配列を返す。

- 配列よりもコレクションの方を使用する

- メモリ消費量の最小化と性能最大化のために、低レベル API では配列の使用を検討する。バイトの配列等。

* プロパティのゲッターが呼び出されるたびに新しい配列を返す必要があるならば、そのプロパティに配列を使用してはならない

* 新しいコレクションを設計するときには、IEnumrable<T>を実装する。そうすることに意味があるならば ICollection<T>,IReadOnlyList<T>,または IList<T>の実装を検討する

* IDictionary または IDictionary<TKey, TValue>を実装する抽象の名前に、Dictionary サフィックスを使用する

* 正確な時刻を参照するときは、常に DateTimrOffset を使用する

* タイムゾーンをまたいで適用される店舗の営業時間のような、絶対的な時刻が適用されないケースでは DateTime を使用する

* 誕生日のような終日の日付を表現するには、DateTimeOffset ではなく、時刻部分が 00:00:00 の DateTime を使用する

* 日付のない時刻を表現するには、TimeSpan を使用する

* ICloneable を実装してはならない

* Clone の仕組みが必要な型では、Clone メソッドを定義することを検討する。その型のドキュメントでは、ディープコピーかシャローコピー明示するようにする

* 値型に IEquatable<T>を実装する

* IEquatable<T>を実装するとは、常に Object.Equal をオーバーライドする

* IEquatable<T>を実装するときは、常に==演算子と!=演算子のオーバーロードを検討する

* IComparable<T>を実装するときは、常に IEquatable<T>を実装する

* System.DBNull の使用を避ける。代わりに、Nullable<T>の方を使用する

* Object.Equal をオーバーライドするときは、Object.Equal で定義されたコントラクトに準拠する

* Equals をオーバーライドするときは、常に IEquatable<T>の実装を検討する

* Equals から例外をスローしてはならない

* 値型では Equals をオーバーライドする

* IEquatable<T>を実装することで、その値型のパラメータを受けとる Equals のオーバーロードを提供する

* 変更可能な参照型で値の透過性を実装してはならない

* Object.Equals をオーバーライドするならば、GetHashCode をオーバーライドする

* 型のすべてのインスタンスについて GetHashCode が生成する値が一様分布になるよう手を尽くす

* オブジェクトに何らかの変更がない限り、GetHashCode が全く同じ値を返すようにする

* 人間が読むことのできる、意味のある文字列を返すことが出来るならば、常に ToString をオーバーライドする

* ToString に外部からわかる副作用をもたせないようにする

* ISerializable インターフェイスのメンバーは明示的に実装する

* URI と URL のデータを表すには System.Uri を使用する

* 可能であれば Url ベースのオーバーロードを呼び出す

* URL や URI の文字列を保持してはならない

* XML データを表すのに、XmlNode や XmlDocument を使用しない。代わりに IXPathNavigable,XmlReader,XmlWriter,または XNode のサブタイプのインスタンスの方を使用する

* Object.Equal と統治演算子が全く同じセマンティクスを持ち、かつよく煮た性能特性を持つようにする

* 等値演算子から例外をスローしてはならない

* ==演算子を定義する型では、演算子と同じ振る舞いをするように IEquatable<T>を実装する

* 引数の型が異なる==演算子の定義を避ける

* 等値比較に意味があるならば、値型で等値演算子をオーバーロードする

## 共通のデザインパターン

- 因子型：集約コンポーネントは最も一般的な抽象度の高い操作に対するショートカットを提供するものであり、より複雑だが協力でもある一連の型に対するファサードとして実装されるのが一般的。この一連の型を因子型という

- 集約コンポーネントを使用して、システムレベルのタスクではない抽象度の高いコンセプトをモデル可する

- 非常に単純な初期化処理だけで使用できるように集約コンポーネントを設計する

- 集約コンポーネントは単一のシナリオにおいて、明示的な複数のオブジェクトのインスタンス化をユーザーに求めてはならない

- 集約コンポーネントは作成ー設定ー呼び出しパターンを必ずサポートするようにする

- 全ての集約コンポーネントに対して、既定の、あるいは非常に単純なコンストラクターを提供する

- 集約コンポーネントのコンストラクターのすべてのパラメータに対して、ゲッターとセッターを持つプロパティを提供する

- 集約コンポーネントでは、デリゲートを渡す API ではなく、イベントを使用する

- 一般的なシナリオにおいて、集約コンポーネントのユーザーに何らかのコード記述以外の作業を求めてはならない。例えば、構成ファイルやリソースファイルの生成等

- 因子型をモードを持つように設計してはならない

- 新しい非同期 API はタスクベース非同期パターンを使用して実装する

- クラシック非同期パターンまたはイベントベース非同期パターンの API の、タスクベース非同期パターンの API をアップグレードを検討する

- 非同期メソッドに名前を付けるときはサフィックスとして Async を使用する

- 非同期メソッドでは cancellationToken という名前の CancellationToken 型のパラメータを受け取る

- CancellationToken 型のパラメータに規定値を提供する

- 実行時間が長い同期メソッドから Task を返してはならない

- Async サフィックス付きのメソッドで ref または out パラメータ修飾子を使用してはならない

- 仮想または抽象 Async サフィックス付きメソッドで in パラメータ修飾子を使用してはならない

- async メソッドが戻り値を返さないなら Task を返す、それ以外は Task<TResult>を返す

- 可能ならばメソッドの同期版と非同期版でパラメータの順序を同じにする

- null の Task または Task<TResult>を返してはならない

- Created 状態のタスクを返してはならない

- CancellationToken によって中止された場合は OperationCanceledException をスローする

- アプリケーションモデルが同期コンテキストに依存している場合を除き、非同期処理を await で待ち受けるときには await task.ConfigureAwait(false)を使用する

- 非同期メソッドで Task.Wait()メソッドの呼び出し、または Task.Result プロパティの読み取りをしてはならない。代わりに await を使用する

- 非同期メソッドの実装では、同期版のメソッドではなく非同期版のメソッドを呼び出す

- デバッグ容易性を向上できるように、使用法エラー例外は非同期メソッドから直接スローする

```
// ダメな例
public async Task SaveAsync(string filename) {
  if (filename == null)
    throw new ArgumentNullException(nameof(filename));
  ・・・
}
//良い例
public Task SaveAsync(string filename){
  if (filename == null)
    throw new ArgumentNullException(nameof(filename));

   return SaveAsyncCore(uri)

}
```

- 非同期メソッドから返された Task 敬の値から実行エラー例外をスローする

* IAsyncEnumrable<T>を返すメソッドに Async サフィックスを使用する

* yield return を使用する IAsyncEnumrable<T>メソッドの CancellationToken 型のパラメーターに、[EnumratorCancellation]属性を追加する

* IAsyncEnumrable<T>と IAsyncEnumrator<T>の両方を同じ公開型で実装してはならない

* await foreach を使用する場合、await を使用する場合と同様に ConfigureAwait 修飾子を使用する

* 依存関係プロパティを実装する場合、DependencyObject か、またはその派生クラスのいずれかを継承する

* 各依存関係プロパティには、通常の CLR のプロパティと、System.Windows.DepndencyProperty 型のインスタンスを保存する public static readonly フィールドを提供する

* 依存関係プロパティの政敵フィールドの名前は、プロパティ名に Property サフィックスを付加する

* 依存関係プロパティの規定値をコード内で明示的に指定してはならな。規定値はメタデータを設定する。

* 依存関係プロパティのアクセサーには、静的フィールドにアクセスするための標準的なコード以外の記述をしてはならない

* セキュリティで保護する必要のあるデータを依存関係プロパティに保存してはならない。パブリックにアクセスできる

* 依存関係プロパティのバリデーションロジックはプロパティのアクセサーに指定してはならず、DependencyProperty.Register メソッドにバリデーションコールバックを渡さなければならない

* 依存関係プロパティのアクセサーに値の強制ロジックを実装してはならない。依存関係プロパティには組込みの値の強制機能があり、これは PeopertyMetadata に対しての値の強制コールバックを与えることで使用できる

* 破棄可能な型のインスタンスを含む型では基本 Dispose パターンを実装する

* マネージドリソースとアンマネージドリソースの解放に関係するすべてのロジックを集約するために、protected virtual void Dispose(bool disposing)メソッドを宣言する(明示的な dispose は true,ファイナライザなら false)

* IDisposable インターフェイスを単純に Dispose(true)を呼び出してから、GC.SuppressFinalize(this)を呼び出すようにする

* パラメータのない Dispose()メソッドを仮想にしてはならない

* Dispose()と Dispose(bool)以外に Dispose メソッドのオーバーロードを宣言してはならない

* Dispose メソッドは複数回呼ばれてもいいようにする。このメソッドは 2 回目以降の呼び出しに対しては何もしないことを選択しても構わない

* オブジェクトが破棄された後に使用できないすべてのメンバーは、ObjectDisposedException をスローする

* Disposed()が呼び出された後に、オブジェクトが意味のある状態に復帰可能である事態を避ける(再ハイドレートを避ける)

* 公開する型をファイナライズ可能にしてはならない

* すべてのファイナライズ可能な型に基本 Dispose パターンを実装する

* すでにファイナライズされているかもしれないという大きなリスクがあるので、ファイナライザーのコードパスでファイナライズ可能なオブジェクトにアクセスしてはならない

* 一度宣言したならば、シールされていない公開型からファイナライザーを削除してはならない

* IAsyncDisposable を実装するときは、別途注記がない限り、非同期処理の設計と同期処理の Dispose パターンの設計の両方のガイダンスに従う

* DisposeAync()のオーバーロードは宣言してはならない

* DisposeAsync の実装は、DisposeAsyncCore()の呼び出し、その結果の await での待ち受け、Dispose(false)の呼び出し、GC.SuppressFinalize(this)の呼び出しを、この順番で行うだけにする

* await using を使用するときは、await の場合と同じように ConfigureAwait 修飾子を使用する

* 一般的に特別なオブジェクト構築の仕組みよりも使いやすく、一貫性があり、便利なので、ファクトリよりもコンストラクターを選択する

* 基底クラスやインターフェイスに対してコーディングする場合など、開発者がどの型が構築されるのか分からない可能性があるときは、ファクトリを使用する

* Parse や Decode といった変換スタイルの処理に対して、ファクトリを使用する

* プロパティではなくメソッドとして、ファクトリ処理を実装する

* 作成された方とは別のファクトリメソッドが宣言されている場合、ファクトリメソッドの名前を Create に作成される型の名前を付けたものにすることを検討する

* ファクトリ型の名前を、作成される型の名前に Factory を付けたものにすることを検討する

* 基本的な LINQ サポートを有効にするために、IEnumrable<T>を実装する

* クエリ演算子の性能を向上させるために、ICollection<T>の実装を検討する

* IQueryable<T>を実装することによって暗黙的にもたらされる性能上の特徴を理解しないまま、Iqueryable<T>を実装してはならない

* データソースによって論理的にサポートされない IQueryable<T>のメソッドからは NotSupportedException をスローする

* クエリパターンを実装する型で IEnumrable<T>を実装する

* 順序付けされたシーケンスは順序付けされていないシーケンスとは別の型として表す

* 順序付けされたシーケンス型では、ThenBy メソッドを定義するか、または IOrderedEnumrable<T>を実装する

* クエリ演算子の実装を遅延実行させる。クエリパターンのほとんどのメンバーに期待されている動作は、列挙可能なオブジェクトに対して、クエリに一致するセットの要素群を生成する新しいオブジェクトを構築するだけである

* クエリ用の拡張メソッドを、メインの名前空間の Linq サブ名前空間に配置する。例えば、System.Data の機能に対する拡張メソッドは System.Data.Linq 名前空間に配置する

* クエリの内容を検査する必要がある場合、ぱためーたで Func<...>の代わりに Expression<Func<…>>を使用する。

* オプション機能がサポートされているかどうか判定するために呼び出し元が使用可能な、単純なブール型のプロパティを提供する

* オプション機能を定義するために、基底クラスでは NotSupportedException をスローする仮想メソッドを使用する

* 型パラメータがインターフェースにおいて、メソッドの入力パラメータとしてのみ使用される場合、ジェネリックインターフェイスのジェネリック型パラメータを反変としてマークする

* 型パラメータが出力として使用され、入力として使用されず、かつ使用中の言語が共変の型の作成をサポートしている場合、ジェネリックデリゲートのジェネリック型パラメータを共変としてマークする

* テンプレートメソッドぱらーんでは public なメンバーを仮想にすることを避ける

* 引数とオブジェクト自身の状態のバリデーションは、テンプレートメソッドパターンの非同期メンバー内で仮想メンバーを呼び出す前に実行する

* テンプレートメソッドパターンの仮想メンバー内で行う引数とオブジェクト自身の状態のバリデーションは、派生型に固有のものだけを実行する

* ユーザーがタイムアウト時間を提供するための仕組みとして、メソッドのパラメーターの方をプロパティより優先する

* タイムアウト時間の表現には TimeSpan を優先して選択する

* タイムアウト時間が終了したときには、System.TimeoutException をスローする

* タイムアウトの発生を示すエラーコードを返してはならない

* XAML で型を記述したいときは、既定のコンストラクターの提供を検討する

* バッファーを表すために、Span の使用を検討する

* 可能であれば、Span<T>ではなく ReadOnlySpan<T>を使用する

* 返される Span の生存期間が極めて明確な場合を除き、Span<T>や ReadOnlySpan<T>を返すことを避ける

* 呼び出し元が渡したものではない、戻り値で返す Span については、所有権の規則に対する明確なドキュメントを提供する

* 変更されないデータを表すために、読み取り専用プロパティまたはパラメータのないメソッドから ReadOnlySpan<T>を返すことを検討する

* 非同期メソッドでは ReadOnlySpan<T>の代わりに ReadOnlyMemory<T>を使用する

* 非同期メソッドでは Span<T>の代わりに Memory<T>を使用する

* コンストラクターまたはメソッドの目的がバッファーへの参照をフィールドに保持することである場合、パラメータで ReadOnlySpan<T>ではなく ReadOnlyMemory<T>を使用する

* 1 つの出力バッファーと単一の入力バッファーを受け取るメソッドでは、その入力バッファーパラメータの名前として source を優先的に使用する

* 単一のバッファーに対して書き込みを行うメソッドでは、その出力バッファーパラメータの名前として destination を優先的に使用する

* 呼び出し元に対して、各出力先バッファーに対して書き込んだ要素数を知らせる

* 小さく実質的イに固定の数の要素を出力先バッファーに書き込む処理については、単純なバッファー書き込み形式のメソッドを提供する

* データの量が小さい場合、または処理が意味のある部分的な結果を生成できない場合、可変量データを書き込むバッファー書き込みに対して Try-Write パターンを使用する

* Try-Write メソッドでは、出力先が小さすぎる場合以外の一切のエラーについて、false を返すのではなく例外をスローする

* OperationStatus メソッドにて正常に処理された入力値の数を out パラメータ経由で報告する

* OperationStatus メソッドが最後の入力ブロックを特別な方法で処理する必要がある場合、isFinalBlock という名前のブール型のパラメータを含める。このパラメータは省略可能で規定値を true とする

## C#コーディングスタイル規約

- 可読性を向上できる場所では、コードの段落の後に空行を入れる

- 絶対に必要な場合を除き this を使用してはならない

- 変数宣言とメソッド呼び出しの両方において、BCL の型名(String, Int32, Double など)を使用してはならない

- new, as キャスト、　または「ハード」キャストの結果を格納する場合を除き、var キーワードを使用してはならない(※一目して型が判断できないものに var を使わない)

- 使用可能な場所ではオブジェクト初期化子を使用する

- 使用可能な場所ではコレクション初期化子を使用する

- 実装が変更されないとおもわれるときは、自動実装プロパティを使用する

- コードでは ASCII 文字のみ使用し、非 ASCII 文字が必要な時はエスケープシーケンス(\uXXXX)を使用する

* 型、メンバー、またはパラメータの名前を参照するときは、

* internal フィールドと private フィールドを除き、名前空間、型、およびメンバーの名前にはパスカルケースを使用する

* internal フィールドと private フィールド、ローカル変数、パラメータにはキャメルケースを使用する

* private または internal なインスタンスフィールドにはプレフィックスとして*を使用し、private または internal な静的フィールドには s*を使用し、private または internal なスレッド静的フィールドには t\_を使用する

* ハンガリアン記法を使用してはならない(変数の型を変数名に含めてはならない)

* コーダー以外の誰かにとって明白ではない何かを記述する場合を除き、コメントを使用してはならない

* ソースファイルに複数の public 型を含めてはならない。ただし、ジェネリックパラメータの数のみが異なる場合や、public なネスト型が１つ以上あるために複数となる場合は除く

* ソースファイルの穴目を、そのファイルが含む public 型の名前にする

* 名前空間の階層構造と同じようにディレクトリの階層構造を編成する

* メンバーを次に示す順序でグループ化する

  - 定数フィールド
  - 静的フィールド
  - インスタンスフィールド
  - 自動実装静的プロパティ
  - 自動実装インスタンスプロパティ
  - コンストラクター
  - メンバー
  - ネスト型

* using ディレクティブをアルファベット順に並べる。全ての名前空間を最初に配置する
